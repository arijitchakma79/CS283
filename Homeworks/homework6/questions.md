1) My implementation ensures all child processes complete by using a loop with waitpid() to wait for each child process by its specific PID. Without these waitpid() calls, child processes would  consume system resources but cannot be fully removed from the process table. These processes would accumulate over time, potentially exhausting the system's process table capacity, and command outputs could appear unexpectedly after new prompts are displayed.

2) Closing unused pipe ends after dup2() is crucial because each pipe creates file descriptors, which are limited resources. If unused pipe ends remain open, they prevent EOF signals from being sent properly since a pipe only indicates EOF when all write ends are closed. This can lead to processes hanging indefinitely waiting for data that will never arrive, causing deadlocks in the pipeline or resource leaks that eventually exhaust the system's file descriptor table.

3) The cd command must be built into the shell because it needs to change the current working directory of the shell process itself. If implemented as an external command, cd would change only its own process's directory and, upon termination, have no effect on the parent shell. The user would see no error messages but would find their shell's directory unchanged, creating a confusing experience where the command appears to succeed but actually fails to accomplish its purpose.

4) To support an arbitrary number of piped commands, I would replace the fixed-size array in command_list_t with a dynamically allocated array and implement resizing functionality using realloc(). This approach would require careful memory management, including proper initialization, resizing when necessary, and thorough freeing of resources to prevent memory leaks. The trade-offs include increased code complexity, additional overhead from memory allocations, and the need for robust error handling, but it would provide better flexibility than the current fixed-size implementation.