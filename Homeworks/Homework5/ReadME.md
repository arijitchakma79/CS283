1) 
The use of fork/execvp instead of just execvp directly is crucial for how a shell operates. When we call execvp, it completely replaces the current process image with a new one. If we called execvp directly from our shell, it would terminate our shell process and replace it with the new command. By using fork first, we create a child process that is a copy of our shell, and then that child process can safely call execvp without affecting the parent shell. This allows our shell to continue running while commands execute in separate processes. Additionally, this separation provides process isolation, allowing the shell to monitor and control the execution of commands, wait for their completion, and handle their exit status.

2)  
The use of fork/execvp instead of just execvp directly is crucial for how a shell operates. When we call execvp, it completely replaces the current process image with a new one. If we called execvp directly from our shell, it would terminate our shell process and replace it with the new command. By using fork first, we create a child process that is a copy of our shell, and then that child process can safely call execvp without affecting the parent shell. This allows our shell to continue running while commands execute in separate processes. Additionally, this separation provides process isolation, allowing the shell to monitor and control the execution of commands, wait for their completion, and handle their exit status.
My implementation handles fork failures robustly. If fork() returns -1, indicating a failure, the code immediately prints an error message using perror("fork") and exits with EXIT_FAILURE. This failure handling is crucial because fork can fail for various reasons, such as the system reaching its process limit or running out of memory. Without proper error handling, the program could continue with undefined behavior, potentially causing system instability or data corruption. The error message helps users understand what went wrong, and the clean exit prevents cascading failures.

3) 
execvp finds commands to execute by utilizing the PATH environment variable. When you execute a command like "ls", execvp searches through each directory listed in PATH (like /usr/bin, /bin, etc.) until it finds an executable with that name. The 'p' in execvp specifically indicates that it should use the PATH variable for this search, unlike other exec variants that require full file paths. This makes it perfect for shell implementation as users can execute commands without needing to know their exact location in the filesystem. For example, when a user types "gcc", execvp might find it at /usr/bin/gcc by searching through PATH.

4) 

The wait() system call in the parent process serves several critical purposes. First, it prevents the creation of zombie processes. When a child process terminates, it doesn't completely disappear from the system until its parent collects its exit status using wait(). Without wait(), terminated child processes would remain as zombies, consuming system resources. Second, wait() allows the parent to synchronize with its children, ensuring that the shell prompt doesn't appear until the command has finished executing. Third, it enables the parent to collect the child's exit status, which is important for shell scripting and error handling. If we didn't call wait(), we'd have zombie processes accumulating and lose the ability to track command execution status.

5) 

WEXITSTATUS() is a macro that extracts the actual exit code (a value between 0 and 255) from the status value returned by wait(). This information is crucial for several reasons. In shell scripting, the exit status determines whether a command succeeded (typically indicated by 0) or failed (non-zero value). This allows for conditional execution of commands based on the success or failure of previous commands. It's also important for error handling and debugging, as specific exit codes can indicate different types of failures. While our current implementation doesn't use WEXITSTATUS(), it would be valuable for adding more sophisticated error handling and command chaining features.

6) 

Our build_cmd_buff() implementation handles quoted arguments carefully to preserve the exact intention of the user's command. When parsing the command line, it keeps track of whether it's currently inside quotes using an in_quotes flag. While inside quotes, spaces are preserved rather than being treated as argument separators. This is necessary because many commands need to handle arguments containing spaces, such as filenames or text strings. For example, when a user types echo "hello world", the quotes indicate that "hello world" should be passed as a single argument rather than two separate ones. Without this quote handling, it would be impossible to pass arguments containing spaces or other special characters to commands.

7) 

Compared to the previous assignment, the parsing logic underwent several important changes. We added robust quote handling to properly process arguments with spaces and special characters. The space handling was improved to better handle leading and trailing spaces while preserving quoted content. We also enhanced error checking to catch more edge cases and provide better feedback. One unexpected challenge was maintaining backward compatibility while adding these new features. We had to carefully refactor the code to ensure that existing functionality continued to work while adding support for quoted arguments and more complex command structures.

8) 

Signals in Linux serve as a software interruption system, providing a way for processes to communicate about important events. Unlike other forms of interprocess communication (IPC) which focus on data transfer, signals are lightweight notifications primarily used for process control and error handling. They can't carry data beyond their signal number and can be lost if multiple signals arrive simultaneously. Common signals include SIGKILL (signal 9), which forces immediate process termination and cannot be caught or ignored; SIGTERM (signal 15), which requests graceful process termination and can be caught by the process; and SIGINT (signal 2), which is typically triggered by Ctrl+C and allows for interactive program interruption. SIGSTOP is special because, like SIGKILL, it cannot be caught or ignored by the process. This design ensures that the system always has a way to suspend process execution, which is crucial for process control and debugging. SIGSTOP can be paired with SIGCONT to implement process suspension and resumption.
